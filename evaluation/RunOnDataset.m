%% Evaluate demosaicking, spectral reconstruction, and/or chromatic aberration correction
% Run algorithms on a dataset to evaluate demosaicking, spectral
% reconstruction, and/or chromatic aberration correction
%
% ## Usage
% Modify the parameters, the first code section below, then run.
%
% ## Input
%
% The dataset determines the data to be loaded, the algorithms to be
% tested, and the types of evaluations to perform, as encapsulated by the
% 'describeDataset()' function.
%
% The documentation in the scripts 'CorrectByHyperspectralADMM.m' and
% 'CorrectByWarping.m' contains more information on the formats of the
% various types of data associated with the datasets.
%
% This script also runs 'SetFixedParameters.m' to set the values of
% seldomly-changed parameters. These parameters are briefly documented in
% 'SetFixedParameters.m'.
%
% In contrast with 'CorrectByHyperspectralADMM.m', the wavelengths at which
% hyperspectral images are to be sampled are either determined from ground
% truth hyperspectral data, or are otherwise set by 'SetFixedParameters.m',
% but are not loaded from colour space conversion data or dispersion model
% data.
%
% ## Output
%
% ### Estimated images
%
% The following types of images are created for each input image, depending
% on the image estimation algorithms. The filename of the input image,
% concatenated with a string of parameter information, is represented by
% '*' below:
% - '*_roi.tif' and '*_roi.mat': A cropped version of the input image
%   (stored in the variable 'I_raw'), containing the portion used as input.
%   This region of interest was determined using the domain of the model of
%   dispersion associated with the dataset. If no model of dispersion is
%   associated with the dataset, the cropped region is the entire input
%   image. All of the other output images listed below are limited to the
%   region shown in this output image.
% - '*_latent.mat': The estimated latent spectral image (stored in the
%   variable 'I_latent') corresponding to the input image.
% - '*_rgb.tif' and '*_rgb.mat': A colour image (stored in the variable
%   'I_rgb'). If it was not estimated directly, it was created by
%   converting the latent image to the RGB colour space of the input image.
%
% ### Data file output
%
% #### Evaluation and algorithm parameters
% A '.mat' file containing the following variables:
%
% - 'dataset': A character vector containing the name of the dataset used
%   for evaluation
% - 'wavelengths': A vector containing the wavelengths of the spectral
%   bands used in hyperspectral image estimation.
% - 'sensor_map_resampled': A resampled version of the 'sensor_map'
%   variable loaded from colour space conversion data.
%   'sensor_map_resampled' is the spectral response functions of the camera
%   (or, more generally, of the output 3-channel colour space) approximated
%   at the wavelengths in `wavelengths`.
% 
% Additionally, the file contains the values of all parameters listed in
% `parameters_list`, which is initialized in this file, and then augmented
% by 'SetFixedParameters.m'.
%
% ## Notes
% - This script only uses the first row of `patch_sizes`, and the first
%   element of `paddings`, defined in 'SetFixedParameters.m'.
% - This script ignores the `downsampling_factor` parameter defined in
%   'SetFixedParameters.m'.
%
% ## References
%
% The adaptive residual interpolation demosaicking algorithm
% ('third_party/Sensors_ARI/') was developed by Yusuke Monno and Daisuke
% Kiku, and was retrieved from
% http://www.ok.sc.e.titech.ac.jp/res/DM/RI.html
%
% It is described in:
%
%   Yusuke Monno, Daisuke Kiku, Masayuki Tanaka, and Masatoshi Okutomi,
%   "Adaptive Residual Interpolation for Color and Multispectral Image
%   Demosaicking," Sensors, vol.17, no.12, pp.2787-1-21, 2017.

% Bernard Llanos
% Supervised by Dr. Y.H. Yang
% University of Alberta, Department of Computing Science
% File created July 27, 2018

% List of parameters to save with results
parameters_list = {
        'dataset_name',...
        'output_directory'...
    };

%% Input data and parameters

dataset_name = 'kaist';

% ## Parameters for creating radiance images

% CIE D-illuminant
illuminant_filename = '/home/llanos/GoogleDrive/ThesisResearch/Data/20180604_Spectral power distributions_BruceLindbloom/DIlluminants.csv';
illuminant_temperature = 6504; % From https://en.wikipedia.org/wiki/Standard_illuminant#Illuminant_series_D
illuminant_name = 'd65';

% Colour channel to use for radiance normalization
normalization_channel = 2;

% ## Operational parameters

% Output directory for all images and saved parameters
output_directory = '/home/llanos/Downloads';

% Produce console output to describe the processing in this script
verbose = true;

% ## Parameters which do not usually need to be changed
run('SetFixedParameters.m')

% Check for problematic parameters
if add_border
    % Estimating a border area results in images which are usually not
    % registered with the ground truth.
    error('Estimating a border around images prevents quantitative evaluation');
end

%% Load the illuminant

illuminant_data = csvread(illuminant_filename);
bands_illuminant = illuminant_data(:, 1);
S_illuminant = illuminant_data(:, 2:end);
spd_illuminant = ciedIlluminant(...
    illuminant_temperature, bands_illuminant, S_illuminant, bands_illuminant...
);

%% Look up the dataset

dp = describeDataset(dataset_name);

%% Find and/or prepare to generate the dataset images

has_raw = ~isempty(dp.raw_images_wildcard);
has_rgb = ~isempty(dp.rgb_images_wildcard);
has_spectral = ~isempty(dp.spectral_images_wildcard);
has_color_map = ~isempty(dp.color_map);

if ~has_spectral && ~has_rgb
    error('Ground truth (colour or spectral images) must be provided for evaluation.')
end
if ~has_raw && ~has_rgb && (~has_spectral || (has_spectral && ~has_color_map))
    error('RAW images are not available, and cannot be generated.')
end

bands_color = [];
if has_color_map
    % Load colour conversion data
    bands_script = bands;
    bands = [];
    
    optional_variable = 'bands';
    model_variables_required = { 'sensor_map', 'channel_mode' };
    load(dp.color_map, model_variables_required{:}, optional_variable);
    if ~all(ismember(model_variables_required, who))
        error('One or more of the required colour space conversion variables is not loaded.')
    end
    bands_color = bands;
    bands = bands_script;
    
    % Compare with colour space conversion data
    n_bands = length(bands);
    n_bands_sensor_map = size(sensor_map, 2);
    resample_bands = false;
    if ~isempty(bands_color)
        bands_for_interp = bands_color;
        if n_bands ~= length(bands_color) || any(bands ~= bands_color)
            % Resampling is needed
            resample_bands = true;
        end
    elseif n_bands_sensor_map ~= n_bands
        % Resampling is needed, but will be "blind"
        resample_bands = true;
        bands_for_interp = linspace(bands(1), bands(end), n_bands_sensor_map);
    end
    % Resample colour space conversion data if necessary
    if resample_bands
        [sensor_map_resampled, bands] = resampleArrays(...
            bands_for_interp, sensor_map.', bands,...
            bands_interp_method...
            );
        n_bands = length(bands);
        sensor_map_resampled = sensor_map_resampled.';
    else
        sensor_map_resampled = sensor_map;
    end
end

bands_spectral = [];
sensor_map_spectral = [];
if has_spectral
    spectral_filenames = listFiles(dp.spectral_images_wildcard);
    n_images_spectral = length(spectral_filenames);
    n_images = n_images_spectral;
    names = cell(n_images, 1);
    for i = 1:n_images
        [~, names{i}] = fileparts(spectral_filenames{i});
    end
    
    bands = [];
    load(dp.wavelengths, optional_variable);
    if isempty(bands)
        error('No wavelength band information is associated with the spectral images.')
    end
    bands_spectral = bands;
    bands = bands_script;
    
    if has_color_map
        % Check if quantitative evaluation of spectral images is possible
        can_evaluate_spectral = (length(bands_spectral) == n_bands) && all(bands_spectral == bands); 
        if can_evaluate_spectral
            sensor_map_spectral = sensor_map_resampled;
        else
            warning(['Quantitative evaluation of latent images is not possibl'...
                'e because they will be produced at different wavelength'...
                's from the true latent images.']...
            );
        
            % Allow for conversion to colour images
            [sensor_map_spectral, bands_spectral] = resampleArrays(...
                bands_for_interp, sensor_map.', bands_spectral,...
                bands_interp_method...
                );
            sensor_map_spectral = sensor_map_spectral.';
        end
    else
        can_evaluate_spectral = false;
    end
end
if has_rgb
    rgb_filenames = listFiles(dp.rgb_images_wildcard);
    n_images_rgb = length(rgb_filenames);
    rgb_names = cell(n_images_rgb, 1);
    for i = 1:n_images_rgb
        [~, rgb_names{i}] = fileparts(rgb_filenames{i});
    end
    if has_spectral
        if (n_images_spectral ~= n_images_rgb)
            error('Mismatched number of spectral and colour images.');
        end
        for i = 1:n_images_rgb
            if ~strcmp(rgb_names{i}, names{i})
                error('Not all spectral image filenames and colour image filenames match.');
            end
        end
    end
    n_images = n_images_rgb;
    names = rgb_names;
end
if has_raw
    raw_filenames = listFiles(dp.raw_images_wildcard);
    n_images_raw = length(raw_filenames);
    raw_names = cell(n_images, 1);
    for i = 1:n_images
        [~, raw_names{i}] = fileparts(raw_filenames{i});
    end
    if (n_images ~= n_images_raw)
        error('Mismatched number of spectral/colour and RAW images.');
    end
    for i = 1:n_images
        if ~strcmp(raw_names{i}, names{i})
            error('Not all spectral/colour image filenames and RAW image filenames match.');
        end
    end
end

%% Load dispersion models

has_dispersion_rgb = ~isempty(dp.dispersion_rgb_forward) && ~isempty(dp.dispersion_rgb_reverse);
has_dispersion_spectral = ~isempty(dp.dispersion_spectral_reverse);

if has_dispersion_rgb
    [...
        dd_rgb_forward, ~, td_rgb_forward...
    ] = loadDispersionModel(dp.dispersion_rgb_forward, true, false);
    [...
        dd_rgb_reverse, ~, td_rgb_reverse...
    ] = loadDispersionModel(dp.dispersion_rgb_reverse, false, false);
end
if has_dispersion_spectral
    [...
        dd_spectral_reverse, ~, td_spectral_reverse...
    ] = loadDispersionModel(dp.dispersion_spectral_reverse, false, false);
end

%% Process the images

n_channels_rgb = 3;
bands_rgb = 1:n_channels_rgb;
sensor_map_rgb = eye(n_channels_rgb);
n_weights = size(weights, 1);
patch_size = patch_sizes(1, :);
padding = paddings(1);
imageFormationOptions.patch_size = patch_size;
imageFormationOptions.padding = padding;
imageFormationOptions.int_method = int_method;

% Fixed options for ADMM
solvePatchesOptions.add_border = add_border;
baek2017Algorithm2Options.add_border = false;
solvePatchesOptions.patch_size = patch_size;
solvePatchesOptions.padding = padding;

for i = 1:n_images
    if verbose
        fprintf('[RunOnDataset, image %d] Starting\n', i);
    end

    % Generate or load input images, and instantiate dispersion information
    if has_spectral
        I_spectral_gt = loadImage(spectral_filenames{i}, dp.spectral_images_variable);
        
        % Convert to radiance images, if required
        if dp.spectral_reflectances
            original_size = size(I_spectral_gt);
            reflectances = reshape(I_spectral_gt, [], length(bands_spectral)).';
            
            % Resample the illuminant, to avoid resampling the image (which
            % is computationally more expensive)
            [spd_illuminant_i, bands_illuminant_i] = resampleArrays(...
                bands_illuminant, spd_illuminant, bands_spectral,...
                'spline', 'none'...
            );
        
            [~, ~, rad_normalized] = reflectanceToRadiance(...
                bands_illuminant_i, spd_illuminant_i,...
                bands_spectral, reflectances,...
                bands_color, sensor_map.',...
                normalization_channel, int_method...
            );
            
            I_spectral_gt = reshape(rad_normalized.', original_size);
        end
    
        if has_dispersion_spectral
            [df_spectral_reverse, I_spectral_gt] = makeDispersionForImage(...
                dd_spectral_reverse, I_spectral_gt, td_spectral_reverse...
            );
        end
        image_sampling = [size(I_spectral_gt, 1), size(I_spectral_gt, 2)];
        I_spectral_lin = reshape(I_spectral_gt, [], 1);
    elseif has_color_map && has_dispersion_spectral
        df_spectral_reverse = makeDispersionForImage(dd_spectral_reverse);
    elseif has_color_map
        df_spectral_reverse = [];
    end

    if has_rgb
        I_rgb_gt = loadImage(rgb_filenames{i}, dp.rgb_images_variable);
        if has_dispersion_rgb
            [df_rgb_reverse, I_rgb_gt] = makeDispersionForImage(...
                    dd_rgb_reverse, I_rgb_gt, td_rgb_reverse...
                );
            df_rgb_forward = makeDispersionForImage(...
                    dd_rgb_forward, I_rgb_gt, td_rgb_forward...
                );
        end
        if has_spectral
            if any([size(I_rgb_gt, 1), size(I_rgb_gt, 2)] ~= image_sampling)
                error('The colour version of %s has different spatial dimensions from its spectral version.',...
                    names{i}...
                );
            end
        else
            image_sampling = [size(I_rgb_gt, 1), size(I_rgb_gt, 2)];
        end
        I_rgb_lin = reshape(I_rgb_gt, [], 1);
    elseif has_spectral && has_color_map
        [I_rgb_gt, ~, I_raw_gt] = imageFormation(...
            I_spectral_gt, sensor_map_spectral, bands_spectral,...
            imageFormationOptions, df_spectral_reverse, bayer_pattern...
        );
    end
    if ~has_rgb && has_dispersion_rgb
        df_rgb_reverse = makeDispersionForImage(dd_rgb_reverse);
        df_rgb_forward = makeDispersionForImage(dd_rgb_forward);
    elseif ~has_dispersion_rgb
        df_rgb_reverse = [];
        df_rgb_forward = [];
    end
    
    if has_raw
        I_raw_gt = loadImage(raw_filenames{i}, dp.raw_images_variable);
        if ~ismatrix(I_raw_gt)
            error('Expected a RAW image, represented as a 2D array, not a higher-dimensional array.');
        end
        
        % Crop to the region of valid dispersion
        roi = [];
        if has_spectral && has_dispersion_spectral
            roi = modelSpaceTransform(...
                [size(I_raw_gt, 1), size(I_raw_gt, 2)], td_spectral_reverse.model_space, td_spectral_reverse.fill...
                );
        elseif has_rgb && has_dispersion_rgb
            roi = modelSpaceTransform(...
                [size(I_raw_gt, 1), size(I_raw_gt, 2)], td_rgb_reverse.model_space, td_rgb_reverse.fill...
                );
        end
        if ~isempty(roi)
            I_raw_gt = I_raw_gt(roi(1):roi(2), roi(3):roi(4));
        end
        
        if any([size(I_raw_gt, 1), size(I_raw_gt, 2)] ~= image_sampling)
            error('The RAW version of %s has different spatial dimensions from its other versions.',...
                names{i}...
                );
        end
    else
        if has_rgb
            if has_dispersion_rgb
                if verbose
                    fprintf('[RunOnDataset, image %d] Calculating the reverse colour dispersion matrix...\n', i);
                end
                W = dispersionfunToMatrix(...
                    df_rgb_reverse, bands_rgb, image_sampling, image_sampling,...
                    [0, 0, image_sampling(2),  image_sampling(1)], true...
                    );
                if verbose
                    fprintf('\t...done\n');
                end
                I_rgb_warped = warpImage(I_rgb_gt, W, image_sampling);
            else
                I_rgb_warped = I_rgb_gt;
            end
            I_raw_gt = mosaic(I_rgb_warped, bayer_pattern);
        end
    end        
        
    saveImages(...
        output_directory, names{i},...
        I_raw_gt, '_roi', 'I_raw'...
    );
    
    % Run the algorithms
    
    % ADMM
    for w = 1:n_weights
        if has_color_map
            if channel_mode
                baek2017Algorithm2Options.int_method = 'none';
                solvePatchesOptions.int_method = 'none';
            else
                baek2017Algorithm2Options.int_method = int_method;
                solvePatchesOptions.int_method = int_method;
            end
    
            % Spectral space, with L1, L1 priors, without non-negativity
            baek2017Algorithm2Options.norms = [true, true];
            baek2017Algorithm2Options.nonneg = false;
            name_params = [names{i}, sprintf(...
                '_bands%d_L1L1_patch%dx%d_pad%d_weights%eAnd%e_',...
                n_bands, patch_size(1), patch_size(2), padding,...
                weights(w, 1), weights(w, 2)...
                )];
            [...
                I_latent, ~, I_rgb...
            ] = solvePatchesAligned(...
                I_raw_gt, bayer_pattern, df_spectral_reverse,...
                sensor_map_resampled,...
                bands, solvePatchesOptions, @baek2017Algorithm2,...
                {...
                    rho, weights(w, :),...
                    baek2017Algorithm2Options, baek2017Algorithm2Verbose...
                }...
            );
            saveImages(...
                output_directory, name_params,...
                I_latent, 'latent', 'I_latent',...
                I_rgb, 'latent_rgb', 'I_rgb'...
            );
        
            % Spectral space, with L1, L1 priors, and non-negativity
            baek2017Algorithm2Options.norms = [true, true];
            baek2017Algorithm2Options.nonneg = true;
            name_params = [names{i}, sprintf(...
                '_bands%d_L1L1NonNeg_patch%dx%d_pad%d_weights%eAnd%e_',...
                n_bands, patch_size(1), patch_size(2), padding,...
                weights(w, 1), weights(w, 2)...
                )];
            [...
                I_latent, ~, I_rgb...
            ] = solvePatchesAligned(...
                I_raw_gt, bayer_pattern, df_spectral_reverse,...
                sensor_map_resampled,...
                bands, solvePatchesOptions, @baek2017Algorithm2,...
                {...
                    rho, weights(w, :),...
                    baek2017Algorithm2Options, baek2017Algorithm2Verbose...
                }...
            );
            saveImages(...
                output_directory, name_params,...
                I_latent, 'latent', 'I_latent',...
                I_rgb, 'latent_rgb', 'I_rgb'...
            );
        
            % Spectral space, with L1, L2 priors, and non-negativity
            baek2017Algorithm2Options.norms = [true, false];
            baek2017Algorithm2Options.nonneg = true;
            name_params = [names{i}, sprintf(...
                '_bands%d_L1L2NonNeg_patch%dx%d_pad%d_weights%eAnd%e_',...
                n_bands, patch_size(1), patch_size(2), padding,...
                weights(w, 1), weights(w, 2)...
                )];
            [...
                I_latent, ~, I_rgb...
            ] = solvePatchesAligned(...
                I_raw_gt, bayer_pattern, df_spectral_reverse,...
                sensor_map_resampled,...
                bands, solvePatchesOptions, @baek2017Algorithm2,...
                {...
                    rho, weights(w, :),...
                    baek2017Algorithm2Options, baek2017Algorithm2Verbose...
                }...
            );
            saveImages(...
                output_directory, name_params,...
                I_latent, 'latent', 'I_latent',...
                I_rgb, 'latent_rgb', 'I_rgb'...
            );
        
            % Spectral space, with L2, L1 priors, and non-negativity
            baek2017Algorithm2Options.norms = [false, true];
            baek2017Algorithm2Options.nonneg = true;
            name_params = [names{i}, sprintf(...
                '_bands%d_L2L1NonNeg_patch%dx%d_pad%d_weights%eAnd%e_',...
                n_bands, patch_size(1), patch_size(2), padding,...
                weights(w, 1), weights(w, 2)...
                )];
            [...
                I_latent, ~, I_rgb...
            ] = solvePatchesAligned(...
                I_raw_gt, bayer_pattern, df_spectral_reverse,...
                sensor_map_resampled,...
                bands, solvePatchesOptions, @baek2017Algorithm2,...
                {...
                    rho, weights(w, :),...
                    baek2017Algorithm2Options, baek2017Algorithm2Verbose...
                }...
            );
            saveImages(...
                output_directory, name_params,...
                I_latent, 'latent', 'I_latent',...
                I_rgb, 'latent_rgb', 'I_rgb'...
            );
        
            % Spectral space, with L2, L2 priors, and non-negativity
            baek2017Algorithm2Options.norms = [false, false];
            baek2017Algorithm2Options.nonneg = true;
            name_params = [names{i}, sprintf(...
                '_bands%d_L2L2NonNeg_patch%dx%d_pad%d_weights%eAnd%e_',...
                n_bands, patch_size(1), patch_size(2), padding,...
                weights(w, 1), weights(w, 2)...
                )];
            [...
                I_latent, ~, I_rgb...
            ] = solvePatchesAligned(...
                I_raw_gt, bayer_pattern, df_spectral_reverse,...
                sensor_map_resampled,...
                bands, solvePatchesOptions, @baek2017Algorithm2,...
                {...
                    rho, weights(w, :),...
                    baek2017Algorithm2Options, baek2017Algorithm2Verbose...
                }...
            );
            saveImages(...
                output_directory, name_params,...
                I_latent, 'latent', 'I_latent',...
                I_rgb, 'latent_rgb', 'I_rgb'...
            );
        end
        
        baek2017Algorithm2Options.int_method = 'none';
        solvePatchesOptions.int_method = 'none';
        
        % Colour space, with L1, L1 priors, without non-negativity
        baek2017Algorithm2Options.norms = [true, true];
        baek2017Algorithm2Options.nonneg = false;
        name_params = [names{i}, sprintf(...
            '_RGB_L1L1_patch%dx%d_pad%d_weights%eAnd%e_',...
            patch_size(1), patch_size(2), padding,...
            weights(w, 1), weights(w, 2)...
            )];
        I_rgb = solvePatchesAligned(...
            I_raw_gt, bayer_pattern, df_rgb_reverse,...
            sensor_map_rgb,...
            bands_rgb, solvePatchesOptions, @baek2017Algorithm2,...
            {...
                rho, weights(w, :),...
                baek2017Algorithm2Options, baek2017Algorithm2Verbose...
            }...
        );
        saveImages(...
            output_directory, name_params,...
            I_rgb, 'rgb', 'I_rgb'...
        );

        % Colour space, with L1, L1 priors, and non-negativity
        baek2017Algorithm2Options.norms = [true, true];
        baek2017Algorithm2Options.nonneg = true;
        name_params = [names{i}, sprintf(...
            '_RGB_L1L1NonNeg_patch%dx%d_pad%d_weights%eAnd%e_',...
            patch_size(1), patch_size(2), padding,...
            weights(w, 1), weights(w, 2)...
            )];
        I_rgb = solvePatchesAligned(...
            I_raw_gt, bayer_pattern, df_rgb_reverse,...
            sensor_map_rgb,...
            bands_rgb, solvePatchesOptions, @baek2017Algorithm2,...
            {...
                rho, weights(w, :),...
                baek2017Algorithm2Options, baek2017Algorithm2Verbose...
            }...
        );
        saveImages(...
            output_directory, name_params,...
            I_rgb, 'rgb', 'I_rgb'...
        );

        % Colour space, with L1, L2 priors, and non-negativity
        baek2017Algorithm2Options.norms = [true, false];
        baek2017Algorithm2Options.nonneg = true;
        name_params = [names{i}, sprintf(...
            '_RGB_L1L2NonNeg_patch%dx%d_pad%d_weights%eAnd%e_',...
            patch_size(1), patch_size(2), padding,...
            weights(w, 1), weights(w, 2)...
            )];
        I_rgb = solvePatchesAligned(...
            I_raw_gt, bayer_pattern, df_rgb_reverse,...
            sensor_map_rgb,...
            bands_rgb, solvePatchesOptions, @baek2017Algorithm2,...
            {...
                rho, weights(w, :),...
                baek2017Algorithm2Options, baek2017Algorithm2Verbose...
            }...
        );
        saveImages(...
            output_directory, name_params,...
            I_rgb, 'rgb', 'I_rgb'...
        );

        % Colour space, with L2, L1 priors, and non-negativity
        baek2017Algorithm2Options.norms = [false, true];
        baek2017Algorithm2Options.nonneg = true;
        name_params = [names{i}, sprintf(...
            '_RGB_L2L1NonNeg_patch%dx%d_pad%d_weights%eAnd%e_',...
            patch_size(1), patch_size(2), padding,...
            weights(w, 1), weights(w, 2)...
            )];
        I_rgb = solvePatchesAligned(...
            I_raw_gt, bayer_pattern, df_rgb_reverse,...
            sensor_map_rgb,...
            bands_rgb, solvePatchesOptions, @baek2017Algorithm2,...
            {...
                rho, weights(w, :),...
                baek2017Algorithm2Options, baek2017Algorithm2Verbose...
            }...
        );
        saveImages(...
            output_directory, name_params,...
            I_rgb, 'rgb', 'I_rgb'...
        );

        % Colour space, with L2, L2 priors, and non-negativity
        baek2017Algorithm2Options.norms = [false, false];
        baek2017Algorithm2Options.nonneg = true;
        name_params = [names{i}, sprintf(...
            '_RGB_L2L2NonNeg_patch%dx%d_pad%d_weights%eAnd%e_',...
            patch_size(1), patch_size(2), padding,...
            weights(w, 1), weights(w, 2)...
            )];
        I_rgb = solvePatchesAligned(...
            I_raw_gt, bayer_pattern, df_rgb_reverse,...
            sensor_map_rgb,...
            bands_rgb, solvePatchesOptions, @baek2017Algorithm2,...
            {...
                rho, weights(w, :),...
                baek2017Algorithm2Options, baek2017Algorithm2Verbose...
            }...
        );
        saveImages(...
            output_directory, name_params,...
            I_rgb, 'rgb', 'I_rgb'...
        );
    end
    
    % Demosaicking and colour channel warping
    if has_dispersion_rgb
        if verbose
            fprintf('[RunOnDataset, image %d] Calculating the forward colour dispersion matrix...\n', i);
        end
        W = dispersionfunToMatrix(...
            df_rgb_forward, bands_rgb, image_sampling, image_sampling,...
            [0, 0, image_sampling(2),  image_sampling(1)], false...
            );
        if verbose
            fprintf('\t...done\n');
        end
    end
    
    % Bilinear interpolation
    I_rgb_warped = bilinearDemosaic(I_raw_gt, bayer_pattern);
    saveImages(...
        output_directory, names{i},...
        I_rgb_warped, '_bilinear', 'I_rgb'...
    );
    if has_dispersion_rgb
        I_rgb = warpImage(I_rgb_warped, W, image_sampling);
        saveImages(...
            output_directory, names{i},...
            I_rgb, '_bilinear_channelWarp', 'I_rgb'...
        );
    end
  
    % MATLAB's built-in demosaicking
    I_raw_int = im2uint16(I_raw_gt);
    I_rgb_warped = im2double(demosaic(I_raw_int, bayer_pattern));
    saveImages(...
        output_directory, names{i},...
        I_rgb_warped, '_MATLABdemosaic', 'I_rgb'...
    );
    if has_dispersion_rgb
        I_rgb = warpImage(I_rgb_warped, W, image_sampling);
        saveImages(...
            output_directory, names{i},...
            I_rgb_warped, '_MATLABdemosaic_channelWarp', 'I_rgb'...
        );
    end
    
    % Adaptive residual interpolation
    I_rgb_warped = demosaic_ARI(repmat(I_raw_gt, 1, 1, n_channels_rgb), bayer_pattern);
    saveImages(...
        output_directory, names{i},...
        I_rgb_warped, '_ARI', 'I_rgb'...
    );
    if has_dispersion_rgb
        I_rgb = warpImage(I_rgb_warped, W, image_sampling);
        saveImages(...
            output_directory, names{i},...
            I_rgb_warped, '_ARI_channelWarp', 'I_rgb'...
        );
    end
    
    if verbose
        fprintf('[RunOnDataset, image %d] Finished\n', i);
    end
end

%% Save parameters and additional data to a file
save_variables_list = [ parameters_list, {...
        'bands_spectral',...
        'bands_color',...
        'bands',...
        'sensor_map_resampled',...
        'sensor_map_spectral'...
    } ];
save_data_filename = fullfile(output_directory, ['RunOnDataset_' dataset_name '.mat']);
save(save_data_filename, save_variables_list{:});
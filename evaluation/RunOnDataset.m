%% Evaluate demosaicking, spectral reconstruction, and/or chromatic aberration correction
% Run algorithms on a dataset to evaluate demosaicking, spectral
% reconstruction, and/or chromatic aberration correction
%
% ## Usage
% Modify the parameters, the first code section below, then run.
%
% ## Input
%
% The dataset determines the data to be loaded, the algorithms to be
% tested, and the types of evaluations to perform, as encapsulated by the
% 'describeDataset()' function.
%
% The documentation in the script 'CorrectByHyperspectralADMM.m' contains
% more information on the formats of the various types of data associated
% with the datasets.
%
% This script also runs 'SetFixedParameters.m' to set the values of
% seldomly-changed parameters. These parameters are briefly documented in
% 'SetFixedParameters.m'. Regularization weights set in
% 'SetFixedParameters.m' are ignored; Regularization weights are
% automatically selected used if there are no regularization weights
% associated with the individual ADMM-family algorithms, loaded from a file
% generated by 'SelectWeightsForDataset.m'. An output file from
% 'SelectWeightsForDataset.m' will also override the set of ADMM-family
% algorithms to run, which is otherwise determined by running
% 'SetAlgorithms.m'.
%
% ## Output
%
% ### Estimated images
%
% The following types of images are created for each input image, depending
% on the image estimation algorithms. The filename of the input image,
% concatenated with a string of parameter information, is represented by
% '*' below:
% - '*_roi.tif': A cropped version of the input image, containing the
%   portion used as input. This region of interest was determined using the
%   domain of the model of dispersion associated with the dataset. If no
%   model of dispersion is associated with the dataset, the cropped region
%   is the entire input image. All of the other output images listed below
%   are limited to the region shown in this output image.
% - '*_latent.mat': The estimated latent spectral image (stored in the
%   variable 'I_latent') corresponding to the input image.
% - '*_rgb.tif': A colour image. If it was not estimated directly, it was
%   created by converting the latent image to the RGB colour space of the
%   input image. Images which are estimated directly are also saved as
%   '.mat' files (under the variable name 'I_rgb').
%
% For demosaicking algorithms, the colour images are saved under the names
% of the demosaicking algorithms, with no '_rgb' suffix. Furthermore, if
% there is a model of colour dispersion associated with the dataset,
% additional images, '_channelWarp.tif' and '_channelWarp.mat' (using the
% variable name 'I_rgb') are output. These images are corrections of the
% demosaicking results for chromatic aberration using the colour dispersion
% model.
%
% ### Regularization weights images
%
% If automatic regularization weight selection is enabled (see
% `admm_algorithms_filename` in the parameters below), then the image
% estimation algorithm will automatically choose weights on the
% regularization terms in the ADMM optimization problem. For the i-th
% enabled regularization term in the ADMM optimization problem, an image
% will be output, as the variable 'I_weights', in the file
% '*_weight${i}Image.mat', where '*' represents the filename of the input
% image concatenated with a string of parameter information. A pixel in the
% image will contain the weight on the i-th regularization term used when
% estimating the pixel.
%
% ### Data file output
%
% #### Intermediate data and parameters
% A '.mat' file containing the following variables, as appropriate:
% - 'bands': A vector containing the wavelengths of the spectral
%   bands used in hyperspectral image estimation.
% - 'bands_color': The 'bands' variable loaded from the colour space
%   conversion data file, for reference.
% - 'bands_spectral': A vector containing the wavelengths of the spectral
%   bands associated with ground truth hyperspectral images.
% - 'color_weights': A matrix for converting pixels in the estimated
%   hyperspectral images to colour, as determined by the 'sensor_map'
%   variable loaded from the colour space conversion data file, and by the
%   type of numerical intergration to perform.
% - 'color_weights_reference': A matrix for converting pixels in the ground
%   truth hyperspectral images to colour, as determined by the 'sensor_map'
%   variable loaded from the colour space conversion data file, and by the
%   type of numerical intergration to perform.
% - 'spectral_weights': A matrix for converting pixels in the spectral
%   space of the estimated hyperspectral images to the spectral space of
%   the true hyperspectral images.
% - 'admm_algorithms': A structure describing the ADMM algorithms being
%   evaluated, created by 'SetAlgorithms.m' and possibly updated by
%   'SelectWeightsForDataset.m'.
% - 'demosaic_algorithms': A structure describing the demosaicking
%   algorithms being evaluated, created by 'SetAlgorithms.m'.
% 
% Additionally, the file contains the values of all parameters listed in
% `parameters_list`, which is initialized in this file, and then augmented
% by 'SetFixedParameters.m'.
%
% The file is saved as 'RunOnDataset_${dataset_name}.mat'.
%
% #### Evaluation results
%
% For each image, RGB error metrics and (if applicable) spectral error
% metrics are output in the form of CSV files. Each CSV file contains
% results for all algorithms tested. The RGB error metrics are saved as
% '*_evaluateRGB.csv', whereas the spectral error metrics are saved as
% '*_evaluateSpectral.csv'.
%
% Error metrics are also aggregated across images, and saved as
% '${dataset_name}_evaluateRGB.csv' and
% '${dataset_name}_evaluateSpectral.csv'.
%
% ## Notes
% - This script only uses the first row of `patch_sizes`, and the first
%   element of `paddings`, defined in 'SetFixedParameters.m', by using
%   `solvePatchesADMMOptions.patch_options`.
% - If `solvePatchesMultiADMMOptions.sampling_options.show_steps` is
%   `true`, output images will be saved only for the highest spectral
%   resolution, even though the images returned by
%   'solvePatchesMultiADMM()' will contain multiple spectral resolutions.
%   However, there will be additional spectral evaluation figures and CSV
%   files comparing the results between spectral resolutions (for the same
%   image estimation algorithm). Refer to the documentation of
%   'solvePatchesMultiADMM.m' for more information.
%
% ## References
%
% The adaptive residual interpolation demosaicking algorithm
% ('third_party/Sensors_ARI/') was developed by Yusuke Monno and Daisuke
% Kiku, and was retrieved from
% http://www.ok.sc.e.titech.ac.jp/res/DM/RI.html
%
% It is described in:
%
%   Yusuke Monno, Daisuke Kiku, Masayuki Tanaka, and Masatoshi Okutomi,
%   "Adaptive Residual Interpolation for Color and Multispectral Image
%   Demosaicking," Sensors, vol.17, no.12, pp.2787-1-21, 2017.

% Bernard Llanos
% Supervised by Dr. Y.H. Yang
% University of Alberta, Department of Computing Science
% File created July 27, 2018

% List of parameters to save with results
parameters_list = {
        'dataset_name',...
        'admm_algorithms_filename',...
        'output_directory'...
    };

%% Input data and parameters

dataset_name = 'kaist-crop';

% Describe algorithms to run
run('SetAlgorithms.m')

% Optionally override the list of ADMM-family algorithms to run, and the
% regularization weights to run them with, from the output file of
% 'SelectWeightsForDataset.m'. (Leave empty otherwise)
admm_algorithms_filename = '/home/llanos/GoogleDrive/ThesisResearch/Results/20181031_KAIST_RepeatWithNewSpectralSampling/weights_selection/SelectWeightsForDataset_kaist-crop.mat';

% Output directory for all images and saved parameters
output_directory = '/home/llanos/Downloads';

% Produce console output to describe the processing in this script
verbose = true;

% ## Parameters which do not usually need to be changed
run('SetFixedParameters.m')

%% Check for problematic parameters

if use_fixed_weights
    error('Weights should be fixed by running ''SelectWeightsForDataset.m'', not using the `use_fixed_weights` parameter in ''SetFixedParameters.m''');
end

%% Preprocess the dataset

dp = describeDataset(dataset_name);

run('PreprocessDataset.m')

%% Finalize the set of algorithms to run

use_automatic_weights = isempty(admm_algorithms_filename);
if ~use_automatic_weights
    load(admm_algorithms_filename, 'admm_algorithms');
end
admm_algorithm_fields = fieldnames(admm_algorithms);
n_admm_algorithms = length(admm_algorithm_fields);
if use_automatic_weights
    n_weight_types = 1;
else
    n_weight_types = 2; % Each image is assigned MDC and MSE weights
    for f = 1:n_admm_algorithms
        algorithm = admm_algorithms.(admm_algorithm_fields{f});
        if algorithm.enabled && any([...
                size(algorithm.mdc_weights, 3),...
                size(algorithm.mse_weights, 3)
            ] ~= n_images)
            error('Algorithm "%s" does not have a number of weights matching the number of images.', algorithm.name)
        end
    end
end

%% Process the images

patch_size = solvePatchesMultiADMMOptions.patch_options.patch_size;
padding = solvePatchesMultiADMMOptions.patch_options.padding;

e_rgb_tables = cell(n_images, 1);
e_spectral_tables = cell(n_images, 1);

for i = 1:n_images
    if verbose
        fprintf('[RunOnDataset, image %d] Starting\n', i);
    end

    % Generate or load input images, and instantiate dispersion information
    run('LoadAndConvertImage.m');
        
    saveImages(...
        'image', output_directory, names{i},...
        I_raw_gt, '_roi', 'I_raw'...
    );
    
    % Compare the aberrated image to the original
    
    if isempty(I_rgb_gt_warped)
        e_rgb_table = [];
    else
        e_rgb_table = evaluateAndSaveRGB(...
            I_rgb_gt_warped, I_rgb_gt, dp, names{i}, 'Aberrated',...
            fullfile(output_directory, [names{i} '_aberrated'])...
        );
    end
    
    n_spectral_evaluations = 0;
    if has_spectral
        for f = 1:n_admm_algorithms
            algorithm = admm_algorithms.(admm_algorithm_fields{f});
            if algorithm.enabled && algorithm.spectral
                n_spectral_evaluations = n_spectral_evaluations + 1;
            end
        end
        n_spectral_evaluations = n_spectral_evaluations * n_weight_types;
    end
    if ~isempty(I_spectral_gt_warped)
        n_spectral_evaluations = n_spectral_evaluations + 1;
    end
    if n_spectral_evaluations > 0
        evaluation_plot_colors = jet(n_spectral_evaluations);
        if isempty(I_spectral_gt_warped)
            evaluation_plot_colors_admm = evaluation_plot_colors;
        else
            evaluation_plot_colors_admm = evaluation_plot_colors(2:end, :);
        end
        evaluation_plot_markers = {'v', 'o', '+', '*', '<', '.', 'x', 's', 'd', '^', 'p', 'h', '>'};
        evaluation_plot_styles = {'--', ':', '-.'};
    end
    if isempty(I_spectral_gt_warped)
        e_spectral_table = [];
        fg_spectral = struct;
        all_alg_names = {};
    else
        dp.evaluation.global_spectral.plot_color = evaluation_plot_colors(1, :);
        dp.evaluation.global_spectral.plot_marker = 'none';
        dp.evaluation.global_spectral.plot_style = '-';
        all_alg_names = {'Aberrated'};
        [e_spectral_table, fg_spectral] = evaluateAndSaveSpectral(...
            I_spectral_gt_warped, I_spectral_gt, bands_spectral,...
            eye(length(bands_spectral)), dp, names{i}, all_alg_names{1},...
            fullfile(output_directory, [names{i} '_aberrated'])...
        );
    end
    
    % Run the algorithms
    
    % ADMM
    color_ind = 1;
    for w_type = 1:n_weight_types
        for f = 1:n_admm_algorithms
            algorithm = admm_algorithms.(admm_algorithm_fields{f});
            if ~algorithm.enabled || (algorithm.spectral && ~has_color_map)
                continue;
            end
            
            true_spectral = algorithm.spectral && ~channel_mode;
            if true_spectral
                reg_options_f = solvePatchesMultiADMMOptions.reg_options;
            else
                reg_options_f = solvePatchesADMMOptions.reg_options;
            end
            
            if ~use_automatic_weights
                if w_type == 1
                    weights_f = algorithm.mdc_weights(:, :, i);
                elseif w_type == 2
                    weights_f = algorithm.mse_weights(:, :, i);
                else
                    error('Unrecognized type of weight, %d', w_type);
                end
                if true_spectral
                    reg_options_f.multi_weights = weights_f;
                else
                    reg_options_f.minimum_weights = weights_f;
                    reg_options_f.maximum_weights = weights_f;
                end
            end
            reg_options_f.enabled = algorithm.priors;
            
            if true_spectral
                admm_options_f = mergeStructs(...
                    solvePatchesMultiADMMOptions.admm_options, algorithm.options, false, true...
                );
            else
                admm_options_f = mergeStructs(...
                    solvePatchesADMMOptions.admm_options, algorithm.options, false, true...
                );
            end

            name_params = sprintf(...
                '%s_patch%dx%d_pad%d',...
                algorithm.file, patch_size(1), patch_size(2), padding...
                );
            alg_name_params = sprintf(...
                '%s, patch %d x %d, padding %d',...
                algorithm.name, patch_size(1), patch_size(2), padding...
                );
            if use_automatic_weights
                name_params = [name_params, '_mdc_'];
                alg_name_params = [alg_name_params, ', MDC'];
                enabled_weights = reg_options_f.enabled;
                n_active_weights = sum(enabled_weights);
                to_all_weights = find(enabled_weights);
            else
                if w_type == 1
                    name_params = [name_params, '_MDCFixedweights_'];
                    alg_name_params = [alg_name_params, ', MDC fixed weights'];
                elseif w_type == 2
                    name_params = [name_params, '_MSEFixedweights_'];
                    alg_name_params = [alg_name_params, ', MSE fixed weights'];
                else
                    error('Unrecognized type of weight, %d', w_type);
                end
            end
            if algorithm.spectral                
                if true_spectral
                    [...
                        bands_all,...
                        I_latent,...
                        I_rgb,...
                        weights_images...
                    ] = solvePatchesMultiADMM(...
                        [], I_raw_gt, bayer_pattern, df_spectral_reverse,...
                        sensor_map, bands_color,...
                        solvePatchesMultiADMMOptions.sampling_options,...
                        admm_options_f, reg_options_f,...
                        solvePatchesMultiADMMOptions.patch_options,...
                        solvePatchesMultiADMMVerbose...
                    );
                
                    if solvePatchesMultiADMMOptions.sampling_options.show_steps
                        n_bands_t = length(bands_all{end});
                    else
                        n_bands_t = length(bands_all);
                    end
                    name_params = [...
                        names{i}, sprintf('_bands%d_', n_bands_t), name_params...
                    ];
                    alg_name_params = [...
                        alg_name_params, sprintf(', %d bands', n_bands_t)...
                    ];
                
                    % Spectral evaluation of intermediate images
                    if solvePatchesMultiADMMOptions.sampling_options.show_steps
                        n_steps = length(bands_all);
                        step_plot_colors = jet(n_steps);
                        step_name_params_tables = cell(n_steps, 1);
                        
                        spectral_inc = 0;
                        fg_spectral_step = struct;
                        for t = 1:n_steps
                            name_params_t = [name_params, sprintf('step%d_', t)];
                            name_params_tables_t = sprintf('%s, step %d', alg_name_params, t);
                            dp.evaluation.global_spectral.plot_color =...
                                step_plot_colors(t, :);
                            dp.evaluation.global_spectral.plot_marker =...
                                evaluation_plot_markers{...
                                mod(t - 1, length(evaluation_plot_markers)) + 1 ...
                                };
                            dp.evaluation.global_spectral.plot_style =...
                                evaluation_plot_styles{...
                                mod(t - 1, length(evaluation_plot_styles)) + 1 ...
                                };
                            step_name_params_tables{t} = name_params_tables_t;

                            n_bands_t = length(bands_all{t});
                            spectral_weights_step = upsamplingWeights(...
                                bands_spectral, bands_all{t}, @sinc, solvePatchesMultiADMM.sampling_options.bands_padding...
                            );
                            [e_spectral_table_step_current, fg_spectral_step] = evaluateAndSaveSpectral(...
                                I_latent(:, :, (spectral_inc + 1):(spectral_inc + n_bands_t)),...
                                I_spectral_gt, bands_spectral, spectral_weights_step,...
                                dp, names{i}, name_params_tables_t,...
                                fullfile(output_directory, name_params_t(1:(end-1))),...
                                fg_spectral_step...
                                );
                            if t == 1
                                e_spectral_table_step = e_spectral_table_step_current;
                            else
                                e_spectral_table_step = union(e_spectral_table_step_current, e_spectral_table_step);
                            end
                            spectral_inc = spectral_inc + n_bands_t;
                        end
                        writetable(...
                            e_spectral_table_step,...
                            fullfile(output_directory, [name_params, '_multiStep_evaluateSpectral.csv'])...
                        );
                        evaluateAndSaveSpectral(...
                            output_directory, dp, [names{i}, '_multiStep'], step_name_params_tables, fg_spectral_step...
                        );

                        % Retain only the highest spectral resolution data
                        % for further study
                        I_latent = I_latent(:, :, (end - n_bands_t + 1):end);
                        I_rgb = I_rgb(:, :, (end - n_channels_rgb + 1):end);
                        if use_automatic_weights
                            weights_images = weights_images(:, :, (end - n_active_weights + 1):end);
                        end
                    end
                else
                    [...
                        I_latent,...
                        I_rgb,...
                        weights_images...
                    ] = solvePatchesADMM(...
                        [], I_raw_gt, bayer_pattern, df_spectral_reverse,...
                        color_weights, bands,...
                        admm_options_f, reg_options_f,...
                        solvePatchesADMMOptions.patch_options,...
                        solvePatchesADMMVerbose...
                    );
                
                    name_params = [...
                        names{i}, sprintf('_bands%d_', n_bands), name_params...
                    ];
                    alg_name_params = [...
                        alg_name_params, sprintf(', %d bands', n_bands)...
                    ];
                end
                
                saveImages(...
                    'data', output_directory, name_params,...
                    I_latent, 'latent', 'I_latent'...
                );
                saveImages(...
                    'image', output_directory, name_params,...
                    I_rgb, 'latent_rgb', 'I_rgb'...
                );
            
                % Spectral evaluation
                if has_spectral
                    dp.evaluation.global_spectral.plot_color =...
                        evaluation_plot_colors_admm(color_ind, :);
                    dp.evaluation.global_spectral.plot_marker =...
                        evaluation_plot_markers{...
                            mod(color_ind - 1, length(evaluation_plot_markers)) + 1 ...
                        };
                    dp.evaluation.global_spectral.plot_style =...
                        evaluation_plot_styles{...
                            mod(color_ind - 1, length(evaluation_plot_styles)) + 1 ...
                        };
                    color_ind = color_ind + 1;
                    all_alg_names{end + 1} = alg_name_params;
                    [e_spectral_table_current, fg_spectral] = evaluateAndSaveSpectral(...
                        I_latent, I_spectral_gt, bands_spectral, spectral_weights,...
                        dp, names{i}, alg_name_params,...
                        fullfile(output_directory, name_params(1:(end-1))),...
                        fg_spectral...
                    );
                    if ~isempty(e_spectral_table)
                        e_spectral_table = union(e_spectral_table_current, e_spectral_table);
                    else
                        e_spectral_table = e_spectral_table_current;
                    end
                end
            else
                name_params = [...
                    names{i}, '_RGB_', name_params...
                ];
                alg_name_params = [...
                    alg_name_params, ', RGB'...
                ];
            
                [...
                    I_rgb,...
                    ~,...
                    weights_images...
                ] = solvePatchesADMM(...
                  [], I_raw_gt, bayer_pattern, df_rgb_reverse,...
                  sensor_map_rgb, bands_rgb,...
                  admm_options_f, reg_options_f,...
                  solvePatchesADMMOptions.patch_options,...
                  solvePatchesADMMVerbose...
                );

                saveImages(...
                    output_directory, name_params,...
                    I_rgb, 'rgb', 'I_rgb'...
                );
            end
            
            % RGB evaluation
            e_rgb_table_current = evaluateAndSaveRGB(...
                I_rgb, I_rgb_gt, dp, names{i}, alg_name_params,...
                fullfile(output_directory, name_params(1:(end-1)))...
            );
            if ~isempty(e_rgb_table)
                e_rgb_table = union(e_rgb_table_current, e_rgb_table);
            else
                e_rgb_table = e_rgb_table_current;
            end
            
            % Save the selected regularization weights
            if use_automatic_weights
                for w = 1:n_active_weights
                    aw = to_all_weights(w);
                    saveImages(...
                        'data', output_directory, name_params,...
                        weights_images(:, :, w), sprintf('weight%dImage', aw), 'I_weights'...
                    );

                    fg = figure;
                    imagesc(log10(weights_images(:, :, w)));
                    c = colorbar;
                    c.Label.String = sprintf('log_{10}(weight %d)', aw);
                    xlabel('Image x-coordinate')
                    ylabel('Image y-coordinate')
                    title(sprintf('Per-patch regularization weight %d', aw));
                    savefig(...
                        fg,...
                        fullfile(output_directory, [name_params  sprintf('weight%dImage.fig', aw)]),...
                        'compact'...
                        );
                    close(fg);
                end
            end
        end
    end
    
    % Demosaicking and colour channel warping
    demosaic_algorithm_fields = fieldnames(demosaic_algorithms);
    W_forward = [];
    for f = 1:length(demosaic_algorithm_fields)
        algorithm = demosaic_algorithms.(demosaic_algorithm_fields{f});
        if ~algorithm.enabled
            continue;
        end
    
        if ischar(algorithm.fn)
            if strcmp(algorithm.fn, 'matlab')
                I_raw_int = im2uint16(I_raw_gt);
                I_rgb_warped = im2double(demosaic(I_raw_int, bayer_pattern));
            elseif strcmp(algorithm.fn, 'ARI')
                I_rgb_warped = demosaic_ARI(...
                    repmat(I_raw_gt, 1, 1, n_channels_rgb), bayer_pattern...
                );
            else
                error('Unrecognized demosaicking algorithm name.');
            end
        else
            I_rgb_warped = algorithm.fn(I_raw_gt, bayer_pattern);
        end
        saveImages(...
            output_directory, names{i},...
            I_rgb_warped, sprintf('_%s', algorithm.file), 'I_rgb'...
        );
    
        % RGB evaluation
        e_rgb_table_current = evaluateAndSaveRGB(...
            I_rgb_warped, I_rgb_gt, dp, names{i}, algorithm.name,...
            fullfile(output_directory, [names{i} '_' algorithm.file])...
        );
        if ~isempty(e_rgb_table)
            e_rgb_table = union(e_rgb_table_current, e_rgb_table);
        else
            e_rgb_table = e_rgb_table_current;
        end
            
        if has_dispersion_rgb
            
            if isempty(W_forward)
                if verbose
                    fprintf('[RunOnDataset, image %d] Calculating the forward colour dispersion matrix...\n', i);
                end
                W_forward = dispersionfunToMatrix(...
                    df_rgb_forward, bands_rgb, image_sampling, image_sampling,...
                    [0, 0, image_sampling(2),  image_sampling(1)], false...
                    );
                if verbose
                    fprintf('\t...done\n');
                end
            end
    
            I_rgb = warpImage(I_rgb_warped, W_forward, image_sampling);
            saveImages(...
                output_directory, names{i},...
                I_rgb, sprintf('_%s_channelWarp', algorithm.file), 'I_rgb'...
            );
        
            % RGB evaluation
            e_rgb_table_current = evaluateAndSaveRGB(...
                I_rgb, I_rgb_gt, dp, names{i},...
                sprintf('%s, warp-corrected', algorithm.name),...
                fullfile(output_directory, [names{i} '_' algorithm.file '_channelWarp'])...
            );
            if ~isempty(e_rgb_table)
                e_rgb_table = union(e_rgb_table_current, e_rgb_table);
            else
                e_rgb_table = e_rgb_table_current;
            end
        end
    end

    % Write evaluations to a file
    if ~isempty(e_rgb_table)
        writetable(...
            e_rgb_table,...
            fullfile(output_directory, [names{i}, '_evaluateRGB.csv'])...
        );
        e_rgb_tables{i} = e_rgb_table;
    end
    if ~isempty(e_spectral_table)
        writetable(...
            e_spectral_table,...
            fullfile(output_directory, [names{i}, '_evaluateSpectral.csv'])...
        );
        % Also save completed figures
        evaluateAndSaveSpectral(output_directory, dp, names{i}, all_alg_names, fg_spectral);
        e_spectral_tables{i} = e_spectral_table;
    end

    if verbose
        fprintf('[RunOnDataset, image %d] Finished\n', i);
    end
end

%% Save results for all images

e_rgb_tables = e_rgb_tables(~cellfun(@isempty, e_rgb_tables, 'UniformOutput', true));
if ~isempty(e_rgb_tables)
    e_rgb_summary_table = mergeRGBTables(e_rgb_tables);
    writetable(...
        e_rgb_summary_table,...
        fullfile(output_directory, [dataset_name, '_evaluateRGB.csv'])...
    );
end

e_spectral_tables = e_spectral_tables(~cellfun(@isempty, e_spectral_tables, 'UniformOutput', true));
if ~isempty(e_spectral_tables)
    e_spectral_summary_table = mergeSpectralTables(e_spectral_tables);
    writetable(...
        e_spectral_summary_table,...
        fullfile(output_directory, [dataset_name, '_evaluateSpectral.csv'])...
    );
end

%% Save parameters and additional data to a file
save_variables_list = [ parameters_list, {...
    'admm_algorithms', 'demosaic_algorithms'...
} ];
if has_spectral
    save_variables_list = [save_variables_list, {'bands_spectral', 'spectral_weights', 'color_weights_reference'}];
end
if has_color_map
    save_variables_list = [save_variables_list, {'bands', 'bands_color', 'color_weights'}];
end
save_data_filename = fullfile(output_directory, ['RunOnDataset_' dataset_name '.mat']);
save(save_data_filename, save_variables_list{:});